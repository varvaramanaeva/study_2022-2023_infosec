---
## Front matter
lang: ru-RU
title: "Лабораторная работа № 5. Дискреционное разграничение прав в Linux. Исследование влияния дополнительных атрибутов"
subtitle: "Дисциплина: Информационная безопасность"
author:
  - Манаева Варвара Евгеньевна.
institute:
  - Российский университет дружбы народов, Москва, Россия
date: 07 октября 2023

## i18n babel
babel-lang: russian
babel-otherlangs: english

## Formatting pdf
toc: false
toc-title: Содержание
slide_level: 2
aspectratio: 169
section-titles: true
theme: metropolis
header-includes:
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
---

# Цели и задачи работы

## Цель лабораторной работы

Изучение механизмов изменения идентификаторов, применения SetUID- и Sticky-битов. Получение практических навыков работы
в консоли с дополнительными атрибутами. Рассмотрение работы механизма смены идентификатора процессов пользователей, а также
влияние бита Sticky на запись и удаление файлов.

## Задачи

- Настроить по заданию лабораторный стенд;
- Создать программы;
- Подробно разобрать влияние Sticky-бита на удаление и запись файлов.

# Выполение лабораторной работы
# Создание программ

## Войдём в систему от имени пользователя guest.

![Выполнен вход](image/1_1.png){width=80% height=80%}

## Создадим программу simpleid.c:

![Создана программа](image/1_2.png){width=80% height=80%}

## Скомплилируем программу и убедимся, что файл программы создан, командой `gcc simpleid.c -o simpleid`

![Компилируем программу](image/1_3.png){width=80% height=80%}

## Выполним программу simpleid командой `./simpleid`

![Вывод программы `simpleid`](image/1_4.png){width=80% height=80%}

## Выполним системную программу id `id`

![Вывод системной программы](image/1_5.png){width=80% height=80%}

При использовании команды `id`, в отличие от использования написаной нами программы, выводится не только номер пользователя и номер группы,
но и имя пользователя и название группы (в скобках после соответствующих номеров), а также контекст.

## Усложним программу, добавив вывод действительных идентификаторов, и получившуюся программу назовём `simpleid2.c`.

![Создание второй программы](image/1_6.png){width=80% height=80%}

## Скомпилируем и запустим `simpleid2.c` командами:

![Компиляция и запуск второй программы](image/1_7.png){width=80% height=80%}

## Попробуем выполнить команды:

![Не получается выполнить команды](image/1_8.png){width=80% height=80%}

## Повысим временно свои права с помощью su и выполним эти команды.

![Меняем пользователя на суперпользователя и выполняем команды](image/1_9.png){width=80% height=80%}

Команда `chown root:guest /home/guest/lab5/simpleid2` меняет владельца каталога на `root`, а группу каталога меняет на группу 
`guest` (вернее, оставляет без изменений). Команда chmod `u+s /home/guest/lab5/simpleid2` даёт права на выполнение от имени 
суперпользователя.

## Выполним проверку правильности установки новых атрибутов и смены владельца файла simpleid2 командой `ls -l simpleid2`

![Проверка](image/1_10.png){width=80% height=80%}

## Запустим simpleid2 и id

![Выполняем программу и системную программу](image/1_11.png){width=80% height=80%}

Команда `id`, в отличие от написаной программы, выводит только информацию о пользователе, который запросил запуск системной 
программы, в то время как `simpleid2` выводит информацию и о владельце файла, и о том, кто его запускает.

## Проделаем тоже самое относительно SetGID-бита.

![Повторение действий с SetGID](image/1_12.png){width=80% height=80%}

## Создадим программу `readfile.c`

![Создаём программу](image/1_13.png){width=80% height=80%}

## Откомпилируем её командой `gcc readfile.c -o readfile`

![Компилируем программу и проверяем наличие](image/1_14.png){width=80% height=80%}

## Сменим владельца у файла readfile.c (или любого другого текстового файла в системе) и изменим права так, чтобы только суперпользователь (root) мог прочитать его, a guest не мог.

![Изменяем права на файл](image/1_15.png){width=80% height=80%}

## Проверим, что пользователь guest не может прочитать файл `readfile.c` командой `cat /home/guest/lab5/readfile.c`

![Проверка](image/1_16.png){width=80% height=80%}

## Сменим у программы readfile владельца и установим SetUID-бит.

![Меняем владельца](image/1_17.png){width=80% height=80%}

## Проверим, может ли программа readfile прочитать файл readfile.c

![Проверяем возможность чтения файла `readfile.c`](image/1_18.png){width=80% height=80%}

Да, программа может читать данный файл.

## Проверим, может ли программа readfile прочитать файл /etc/shadow

![Проверяем возможность чтения файла `/etc/shadow`](image/1_19.png){width=80% height=80%}

Да, программа может читать данный файл.

# Исследование Sticky-бита

## Выясним, установлен ли атрибут `Sticky` на директории `/tmp` командой `ls -l / | grep tmp`

![Sticky-бит установлен на директории `/tmp`](image/2_1.png){width=80% height=80%}

## От имени пользователя guest создадим файл `file01.txt` в директории `/tmp`со словом test командой `echo "test" > /tmp/file01.txt`

![Создадим файл](image/2_2.png){width=80% height=80%}

## Просмотрим атрибуты у только что созданного файла и разрешим чтение и запись для категории пользователей «все остальные» командами:

![Выдаём права на запись категории пользователей "все остальные"](image/2_3.png){width=80% height=80%}

## От пользователя `guest2` (не являющегося владельцем) попробуем прочитать файл `/tmp/file01.txt` командой `cat /tmp/file01.txt`

![Смотрим содержимое файла](image/2_4.png){width=80% height=80%}

## От пользователя `guest2` попробуем дозаписать в файл `/tmp/file01.txt` слово test2 командой `echo "test2" >> /tmp/file01.txt`

![Дописываем информацию в файл](image/2_5.png){width=80% height=80%}

Операцию выполнить удалось.

## Проверим содержимое файла командой `cat /tmp/file01.txt`

![Смотрим содержимое файла](image/2_6.png){width=80% height=80%}

## От пользователя guest2 попробуем записать в файл `/tmp/file01.txt` слово test3, стерев при этом всю имеющуюся в файле информацию командой `echo "test3" > /tmp/file01.txt`

![Перезаписываем файл](image/2_7.png){width=80% height=80%}

Операцию выполнить удалось.

## Проверим содержимое файла командой `cat /tmp/file01.txt`

![Смотрим содержимое файла](image/2_8.png){width=80% height=80%}

## От пользователя guest2 попробуем удалить файл `/tmp/file01.txt` командой `rm /tmp/fileOl.txt`

![Пытаемся удалить файл](image/2_9.png){width=80% height=80%}

Файл удалить не удалось.

## Повысим свои права до суперпользователя следующей командой `su -` и выполним после этого команду, снимающую атрибут `t` (Sticky-бит) с директории `/tmp`, --- `chmod -t /tmp`

![Снимаем Sticky-бит с директории `/tmp`](image/2_10.png){width=80% height=80%}

## Покинем режим суперпользователя командой `exit`

![Logout](image/2_11.png){width=80% height=80%}

## От пользователя `guest2` проверим, что атрибута `t` у директории `/tmp` нет командой `ls -l / | grep tmp`

![Нет Sticky-бита среди атрибутов директории](image/2_12.png){width=80% height=80%}

## Повторим шаги 4-9.

![Повторение. Получилось удалить файл, что не вышло в прошлый раз](image/2_13.png){width=80% height=80%}

В результате изменения удалось удалить файл от имени пользователя, не являющегося его владельцем.

## Удалось удалить файл от имени пользователя, не являющегося его владельцем.

![Файл удалось удалить](image/2_14.png){width=80% height=80%}

## Повысим свои права до суперпользователя и верните атрибут t на директорию /tmp командами:

![Возвращаем атрибут директории](image/2_15.png){width=80% height=80%}

# Выводы по проделанной работе

## Вывод

В результате выполнения работы мы изучили механизм идентификаторов, применения SetUID- и Sticky-битов, получили практические 
навыки работы в консоли с дополнительными атрибутами, рассмотрели работы механизма смены идентификатора процессов пользователей,
а также посмотрели влияние бита Sticky на запись и удаление файлов.

Были записаны скринкасты выполнения и защиты лабораторной работы.

